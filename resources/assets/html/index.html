<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Style Me Pretty</title>
        <meta name="theme-color" content="#333333">
        <meta name="description" content="A new attempt">
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <link rel="icon" href="/images/favicon.ico" type="image/x-icon" />
        <link rel="manifest" href="/manifest.json">
        <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700,900" type="text/css"> -->
        <link rel="stylesheet" type="text/css" href="/css/app.css">
        <!-- <link rel="stylesheet" type="text/css" href="/css/bundle.css"> -->
        <link rel="service-worker" href="/service-worker.js">
    </head>
    <body>
        <div id="app">
            <router-view></router-view>
        </div>
        <div class="hide">
            <svg xmlns="http://www.w3.org/2000/svg">
            </svg>
        </div>
        <script src="/js/bundle.js" async></script>
        <script>
            /* eslint-env browser */
            'use strict';

            if ('serviceWorker' in navigator) {
                // Delay registration until after the page has loaded, to ensure that our
                // precaching requests don't degrade the first visit experience.
                // See https://developers.google.com/web/fundamentals/instant-and-offline/service-worker/registration
                window.addEventListener('load', function() {
                    // Your service-worker.js *must* be located at the top-level directory relative to your site.
                    // It won't be able to control pages unless it's located at the same level or higher than them.
                    // *Don't* register service worker file in, e.g., a scripts/ sub-directory!
                    // See https://github.com/slightlyoff/ServiceWorker/issues/468
                    navigator.serviceWorker.register('/service-worker.js').then(function(reg) {
                        // updatefound is fired if service-worker.js changes.
                        reg.onupdatefound = function() {
                            // The updatefound event implies that reg.installing is set; see
                            // https://w3c.github.io/ServiceWorker/#service-worker-registration-updatefound-event
                            var installingWorker = reg.installing;

                            installingWorker.onstatechange = function() {
                                switch (installingWorker.state) {
                                    case 'installed':
                                        if (navigator.serviceWorker.controller) {
                                            // At this point, the old content will have been purged and the fresh content will
                                            // have been added to the cache.
                                            // It's the perfect time to display a "New content is available; please refresh."
                                            // message in the page's interface.
                                            console.log('New or updated content is available.');
                                        } else {
                                            // At this point, everything has been precached.
                                            // It's the perfect time to display a "Content is cached for offline use." message.
                                            console.log('Content is now available offline!');
                                        }
                                        break;

                                    case 'redundant':
                                        console.error('The installing service worker became redundant.');
                                        break;
                                }
                            };
                        };
                    }).catch(function(e) {
                        console.error('Error during service worker registration:', e);
                    });
                });
            }
            self.addEventListener('fetch', function(event) {
                event.respondWith(
                    caches.match(event.request)
                        .then(function(response) {
                            // Cache hit - return response
                            if (response) {
                                return response;
                            }

                            // IMPORTANT: Clone the request. A request is a stream and
                            // can only be consumed once. Since we are consuming this
                            // once by cache and once by the browser for fetch, we need
                            // to clone the response.
                            var fetchRequest = event.request.clone();

                            return fetch(fetchRequest).then(
                                function(response) {
                                    // Check if we received a valid response
                                    if(!response || response.status !== 200 || response.type !== 'basic') {
                                        return response;
                                    }

                                    // IMPORTANT: Clone the response. A response is a stream
                                    // and because we want the browser to consume the response
                                    // as well as the cache consuming the response, we need
                                    // to clone it so we have two streams.
                                    var responseToCache = response.clone();

                                    caches.open(CACHE_NAME)
                                        .then(function(cache) {
                                            cache.put(event.request, responseToCache);
                                        });

                                    return response;
                                }
                            );
                        })
                );
            });

            self.addEventListener('fetch', function(event) {
                event.respondWith(
                    caches.match(event.request)
                        .then(function(response) {
                                // Cache hit - return response
                                if (response) {
                                    return response;
                                }
                                return fetch(event.request);
                            }
                        )
                );
            });


            self.addEventListener('activate', function(event) {

                var cacheWhitelist = ['pages-cache-v1', 'blog-posts-cache-v1'];

                event.waitUntil(
                    caches.keys().then(function(cacheNames) {
                        return Promise.all(
                            cacheNames.map(function(cacheName) {
                                if (cacheWhitelist.indexOf(cacheName) === -1) {
                                    return caches.delete(cacheName);
                                }
                            })
                        );
                    })
                );
            });


            </script>
    </body>
</html>
